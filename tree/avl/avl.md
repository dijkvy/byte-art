# AVL (balance binary search tree)
> 自平衡二叉搜索树

## 二叉树的旋转操作

实现一个 AVL, 需要了解[树旋转](https://zh.wikipedia.org/wiki/%E6%A0%91%E6%97%8B%E8%BD%AC)和树平衡

> 树旋转 wikipedia 的定义是对二叉树的一种操作, 不影响元素的顺序(二叉树的中序遍历的结果), 但是会改变树的结构, **将一个结点上移, 一个结点下移**。
> 树的旋转会改变树的形状, 因此长被用来将**较小的子树下移, 较大的子树上移**, 从而降低树的高度、提升许多树的操作效率(主要是查找效率)。



![tree_rotation](./readme_image/tree_rotation.png)

对一棵树进行旋转时, 这棵树的根节点是被旋转的两棵子树的父节点, 称为旋转时的根(**Root**); 如果结点在旋转之后称为新的父结点, 则称该结点为旋转是的转轴(**Pivot**)。上图中, 树的右旋操作以 Q 为根, P 为转轴, 会将树顺时针旋转。 相应的逆操作为左旋, 会以 Q 为转轴, 将树根逆时针旋转。



理解树旋转过程的关键, 在于理解其中不变的约束。 旋转操作不会导致叶子结点的顺序改变(**可以理解为旋转操作前后, 树的中序遍历的结果是一致的**), 旋转过程中也是始终受到二叉搜索树的性质约束: **右子节点比父节点大, 左子节点比父节点小**。尤其需要注意的是, 进行右旋时, 旋转前根节点的左节点的右结点会变成根节点的左结点, 根本身则在旋转后变成新的根的右结点(看下面的动图理解(**β结点**)), 而在这一过程中, 整棵树一直遵守前面提到的约束。相反的左旋操作也是一样的逻辑。



![tree_rotation](./readme_image/tree_rotation_animation.gif)

> golang 是实现二叉树的右旋操作



```go

type (
    AVLTree struct {
        Left  *AVLTree
        Right *AVLTree
        Value int64
    }
)

/******************************************************************************
*           d               b
*          /               / \
*         b       == >    a   d
*        / \                 /
*       a   c               c
* 
* 二叉树的右旋转操作
*******************************************************************************/

// 二叉树的右旋操作
// AVL 树旋转操作之后, 需要调整树当前树为根节点的高度
//
func (root *AVLTree) RightRotation() *AVLTree {
    if root == nil {
        return root
    }
    
    pivot := root.Left
    beta := pivot.Right
    pivot.Right = root
    root.Left = beta
    
    return pivot
}


```



二叉树旋转操作不改变二叉树的**中序**遍历的顺序



树的左右旋转还可以进行组合执行, 称为双旋转(double rotation)。

* 将 X 的右子树右旋, 再将 X 本身左旋, 就是 X 的双左旋转。
* 将 X 的左子树左旋, 再将 X 本身右旋, 就是 X 的双右旋转。



> 二叉树的双左旋转操作

```go
type (
    AVLTree struct {
        Left  *AVLTree
        Right *AVLTree
        Value int64
    }
)

/******************************************************************************
*           d               b
*          /               / \
*         b       == >    a   d
*        / \                 /
*       a   c               c
*
* 二叉树的右旋转操作
*******************************************************************************/

// 二叉树的右旋操作
// AVL 树旋转操作之后, 需要调整树当前树为根节点的高度
//
func (root *AVLTree) RightRotation() *AVLTree {
    if root == nil {
        return root
    }
    
    pivot := root.Left
    beta := pivot.Right
    pivot.Right = root
    root.Left = beta
    
    return pivot
}

/******************************************************************************
*           a               c
*            \             / \
*             c    == >   a   d
*            / \           \
*           b   d           b
*
* 二叉树的左旋转操作
*******************************************************************************/

// 二叉树的左旋操作
// AVL 树旋转操作之后, 需要调整树当前树为根节点的高度
//
func (root *AVLTree) LeftRotation() *AVLTree {
    if root == nil {
        return root
    }
    
    pivot := root.Right
    beta := pivot.Left
    pivot.Left = root
    root.Right = beta
    
    return pivot
}

/******************************************************************************
*           d               d                 c
*          /               /                 / \
*         d       == >    c        =>       b   d
*          \             /
*           c           b
*
* 二叉树的双左旋转操作
*******************************************************************************/

func (root *AVLTree) LeftRightRotation() *AVLTree {
    if root == nil {
        return root
    }
    root.Left = root.Left.LeftRotation()
    
    //root.RightRotation()
    //return root
    return root.RightRotation()
}

```

> 还有一个双右旋操作的





## AVL 的定义

[avl维基百科](https://zh.wikipedia.org/wiki/AVL%E6%A0%91)



AVL 树时最早被发明的**自平衡二叉查找树**。 在 AVL 树中, 任一个结点对应的两棵子树的最大高度差为 1, 因此它被称为高度平衡二叉树。查找、插入和删除在平均和最坏的时间复杂度都是 O(log n) `1.44 * O(log n)`。增加和删除元素的操作可能许哟啊借由一次或者多次的树旋转, 以实现树的重新平衡, 就是 👆 的代码。



### AVL 平衡因子, 节点删除, 增加需要用到的关键因子

节点的平衡因子(balance factor): 是它的左子树的高度减去右子树的高度(有时候是右子树的高度减去左子树的高度)。带有平衡因子值为(1、0 或者 -1) 的节点被认为是平衡的。带有平衡因子 -2 或者 2 的节点被认为是不平衡的, 并且需要重新平衡这课树。平衡因子可以直接保存在每个节点中, 或者可能存储在节点中的子树的高度计算出来(这里实现选择第二种)。



### 删除, 增加节点涉及到的 AVL 旋转

删除和增加节点之后, 二叉树节点的平衡因子可能由原来的 -1 (或者1) 变成 -2 (或者2), 此时可以认为这棵树是不平衡的, 因此一次或者多次旋转操作来使树重新平衡。

**以下图表以四列表示四种情况, 每行表示在改种情况下需要进行的操作。在 左左和右右情况下, 只需要进行一次旋转操作, 在左右和右左的情况下, 需要进行两次旋转操作。**

![tree_Rebalancing](./readme_image/tree_Rebalancing.png)

 插入的实现描述: 

假设平衡因子是左子树的高度减去右子树的高度所得的值, 又假设由于在二叉树上插入节点而失去平衡的最小子树根节点的指针为 a(即 a 是离插入节点最近, 且平衡因子绝对值超过 1 [绝对值是 2] 的祖先节点), 则失去平衡后进行的规律可以归纳为下列四种情况: 

* 左左情况下对应的是右旋, 旋转完之后, 还需要重新调整旋转节点的高度

  > 单向右旋处理平衡 LL: 由于在 *a 的右子树根节点的左子树上插入节点, *a 的平衡因子由 1 增至 2, 致使以 *a 为根节点的子树失去平衡, 则需要一次右旋操作重新平衡

  ```markdonw
  /***********************************************************************************************************************
  *  需要单向右旋的情况是: 原来左子树 a 的平衡因子为 1, 在左子树上继续插入一个节点后, 导致平衡因子变成了 2, 这个时候需要以 a 为根节点进行一次
  *  右旋。
  *
  *  // 举个栗子
  *  
  *            (a:9)                      (a:9)                                                          (b:6)
  *           /                          /                                                              /    \
  *         (b:6)  插入节点(c:4)=>      (b:6)          平衡因子由 1 变成了 2, 需要进行一次右旋操作  =>     (c:4)    (a:9)     
  *                                    /
  *                                (c:4)
  ************************************************************************************************************************/
  ```

  

  ```go
  func (root *AVLTree) RightRotation() *AVLTree {
      if root == nil {
          return root
      }
      
      pivot := root.Left
      beta := pivot.Right
      pivot.Right = root
      root.Left = beta
      
      return pivot
  }
  ```

* 右右的情况下对应的是左旋, 旋转完之后, 还需要重新调整旋转节点的高度

  > 单向左旋平衡处理 RR: 由于在 *a 的右子树根节点的右子树上插入节点, *a 的平衡因子由 -1 变成了 -2, 致使以 *a 为根节点的子树失去了平衡, 则需要一次左旋操。

  ```markdown
  
  /************************************************************************************************************************************
  *  需要单向左旋的情况是: 原来左子树 a 的平衡因子为 -1, 在右子树上继续插入一个节点后, 导致平衡因子变成了 -2, 这个时候需要以 a 为根节点进行一次
  *  左旋。
  *
  *  // 举个栗子
  *
  *            (a:9)                                               (a:9)                                                 (b:20)
  *                 \                                                   \                                                /   \
  *                 (b:20) 在 b 的节点的右子树上插入节点(c:37) 后 =>         (b:20)  平衡因子由原来的 -1 变成 -2, 需要左旋处理 (a:9)    (c:37)
  *                                                                       \
  *                                                                       (c:37)
  ************************************************************************************************************************************/
  ```

  

  ```go
  func (root *AVLTree) LeftRotation() *AVLTree {
      if root == nil {
          return root
      }
      
      pivot := root.Right
      beta := pivot.Left
      pivot.Left = root
      root.Right = beta
      
      return pivot
  }
  ```

* 右左的情况下, 对应的是先左旋(此时已经是左左)在右旋, 旋转完之后再作调节

  > 双向旋转(先右后左) 平衡处理LR: 由于在 *a 的左子树根节点的右子树上插入节点, *a 的平衡因子由原来的 1 增至 2, 致使以 *a 为根节点的子树失去平衡, 需要进行两次旋转(先左旋后右旋)操作

  ```markdonw
  /***********************************************************************************************************************
  *  需要单向先左旋后右旋的情况是: 原来左子树 a 的平衡因子为 1, 在右子树上继续插入一个节点后, 导致平衡因子变成了 2, 这个时候需要以 a 的左子树
  *  为根进行一次左旋, 然后以 a 的为根进行一次右旋
  *
  *
  *  // 举个栗子
  *
  *            (a:10)
  *           /
  *         (b:6)
  *
  *
  *  插入节点 (c:9) 后, 根据二叉查找树的规律, 此时节点 (c:9) 只能在 (b:6) 的右边插入
  *         👇
  *
  *           (a:10)
  *           /
  *          (b:6)
  *               \
  *               (c:9)
  *  此时以 a 为根节点的平衡因子由 1 变成了 2, 需要进行以 a 的左子树为根节点进行一次左旋操作, 调整为以 a 的根节点的, 平衡因子是 2 的类型(LL)
  *              👇
  *
  *           (a:10)
  *           /
  *         (c:9)
  *         /
  *       (b:6)
  *  此时以 a 为根节点的平衡因子依然是 2, 但是不平衡的类型由原来的 LR 变成了 LL, 此时只需要以 a 为根节点的进行一次右旋操作即可
  *            👇
  *
  *           (c:9)
  *           /   \
  *       (b:6)   (a:10)
  ************************************************************************************************************************/
  ```

  

  ```go
  func (root *AVLTree) LeftRightRotation() *AVLTree {
      if root == nil {
          return root
      }
      // 左节点左旋
      root.Left = root.Left.LeftRotation()
      // 根节点右旋
      return root.RightRotation()
  }
  ```

  

* 左右情况下, 对应的是先右旋(此时已经是右右)再左旋, 旋转完之后再作调节

  > 双向旋转(先右后左)平衡处理RL: 由于在 *a 的右子树根节点插入节点, *a 的平衡因子由原来的 -1 变成了 -2, 致使以 *a 为根的子树失去平衡, 则需要进行两次旋转(先右后左)操作。

  ```markdown
  
  /***********************************************************************************************************************
  *  需要单向先右旋后左旋的情况是: 原来右子树 a 的平衡因子为 -1, 在 a 的右子树的左子树上继续插入一个节点后, 导致平衡因子变成了 -2, 这个时候需
  *  要以 a 的右子树为根进行一次右边旋, 然后以 a 的为根进行一次左旋
  *
  *
  *  // 举个栗子
  *
  *            (a:10)
  *                 \
  *                 (b:20)
  *
  *
  *  插入节点 (c:13) 后, 根据二叉查找树的规律, 此时节点 (c:13) 只能在 (b:20) 的左边插入
  *         👇
  *
  *           (a:10)
  *               \
  *              (b:20)
  *               /
  *          (c:13)
  *  此时以 a 为根节点的平衡因子由 -1 变成了 -2, 需要进行以 a 的右子树为根节点进行一次右旋操作, 调整为以 a 的根节点的, 平衡因子是 -2 的类型(RR)
  *              👇
  *
  *           (a:10)
  *                \
  *               (c:13)
  *                   \
  *                  (b:20)
  *  此时以 a 为根节点的平衡因子依然是 -2, 但是不平衡的类型由原来的 RL 变成了 RR, 此时只需要以 a 为根节点的进行一次左边旋操作即可
  *            👇
  *
  *           (c:13)
  *           /   \
  *       (a:10)   (b:20)
  ************************************************************************************************************************/
  ```

  

  ```go
  func (root *AVLTree) RightLeftRotation() *AVLTree {
      if root == nil {
          return root
      }
      // 右节点右旋
      root.Right = root.Right.RightRotation()
      return root.LeftRotation()
  }
  
  ```

  

## 外部链接

* [维基百科 avl](https://zh.wikipedia.org/wiki/AVL%E6%A0%91)